<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Three.js Cube</title>
        <h1 id="point" class="point">Point : 0</h1>
        
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        .point{
            position: absolute;
            font-size: 48px;
            padding: 2rem;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.2/build/three.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
        "imports": {
            "three": "../node_modules/three/build/three.module.js",
            "orbitcontrols": "../node_modules/three/examples/jsm/controls/OrbitControls.js"
        }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'orbitcontrols';

        // Create a Three.js scene
        const scene = new THREE.Scene();

        // Create a camera
        const camera = new THREE.PerspectiveCamera(
            75, // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping plane
            10000 // Far clipping plane
        );
        camera.position.x = 0;
        camera.position.y = 400;
        camera.position.z = 800;
        // camera.position.set(600, 400, 0);

        let compteur = 0;

        // Create a renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a cube
		const poubelleN = createPoubelleN(250, 0, 0);
		let dechet = createDechet(0, 300, 0);
		const poubelleJ = createPoubelleJ(-250, 0, 0);

        scene.add(poubelleN);
		scene.add(dechet);
		scene.add(poubelleJ);
        
        //-----FOND-----------
			const loader = new THREE.TextureLoader();
			const texture = loader.load('./fond.exr');
			const cubeTexture = new THREE.CubeTextureLoader()
			.setPath('./fond.exr')
			.load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);
			scene.background = cubeTexture;
			cubeTexture.opacity = 0.5;
			cubeTexture.needsUpdate = true;

        // Cube produit
        dechet.scale.x = 3;
        dechet.scale.y = 3;
        dechet.scale.z = 3;
        // cube.position.x = 0;
        // cube.position.y = 300;
        // cube.position.z = 0;

        // Cube recyclage
        poubelleJ.scale.x = 10;
        poubelleJ.scale.y = 15;
        poubelleJ.scale.z = 10;
        // cube1.position.x = -250;
        // cube1.position.y = 0;
        // cube1.position.z = 0;

        // Cube pas recyclable
        poubelleN.scale.x = 10;
        poubelleN.scale.y = 15;
        poubelleN.scale.z = 10;
        // cube2.position.x = 250;
        // cube2.position.y = 0;
        // cube2.position.z = 0;

        // const axesHelper = new THREE.AxesHelper(100);
        //   // Ajouter les axes à la scène
        // scene.add(axesHelper);

        const control = new OrbitControls(camera, renderer.domElement)

        // create a raycaster to detect clicks on objects
		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();

		// // add an event listener for clicks
		// window.addEventListener('click', onMouseClick);

		// // function to handle clicks
		// function onMouseClick(event) {
		// 	event.preventDefault();
		// 	mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		// 	mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
		// 	raycaster.setFromCamera(mouse, camera);
		// 	const intersects = raycaster.intersectObjects(scene.children, true);
		// 	if (intersects.length > 0) {
		// 		const selectedObject = intersects[0].object;
		// 		selectedObject.material.color.set(0x00ff00); // change color to green
		// 		setTimeout(() => {
		// 			selectedObject.material.color.set(0xff0000); // change color back to red after 3 seconds
		// 		}, 1000);
		// 	}
		// }

        function createDechet(x, y, z) {
            const geometry = new THREE.BoxGeometry(10, 10, 10);
			const material = new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xcccc00 : 0x000000 });
			const cube = new THREE.Mesh(geometry, material);
            console.log(material);
            cube.color = material.color
			cube.position.set(x, y, z);
			return cube;
		}
        function createDechet2(x, y, z) {
            const geometry = new THREE.BoxGeometry(30, 30, 30);
			const material = new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xcccc00 : 0x000000 });
			const cube = new THREE.Mesh(geometry, material);
			cube.position.set(x, y, z);
			return cube;
		}

        function createPoubelleJ(x, y, z) {
			const geometry = new THREE.BoxGeometry(10, 15, 10);
			const material = new THREE.MeshBasicMaterial({ color: 0xcccc00 });
			const cube = new THREE.Mesh(geometry, material);
			cube.position.set(x, y, z);
			return cube;
		}

        function createPoubelleN(x, y, z) {
			const geometry = new THREE.BoxGeometry(10, 15, 10);
			const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
			const cube = new THREE.Mesh(geometry, material);
			cube.position.set(x, y, z);
			return cube;
		}

		// add an event listener for clicks
		window.addEventListener('click', onMouseClick);
        
		// function to handle clicks
		function onMouseClick(event) {
			event.preventDefault();
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			raycaster.setFromCamera(mouse, camera);
			const intersects = raycaster.intersectObjects(scene.children, true);
			if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
				// if (selectedObject === poubelleN || selectedObject === poubelleJ) {
				// 	scene.remove(dechet);
				// 	// selectedObject.add(dechet);
				// 	// dechet.position.set(0, 0, 0);
                //     const dechet2 = createDechet2(0, 300, 0);
                //     scene.add(dechet2);
                //     // scene.add(cube2)
				// }
                // console.log(dechet.material)
				if (selectedObject === poubelleN && dechet.material.color.r == 0) {
					scene.remove(dechet);
					// selectedObject.add(dechet);
					// dechet.position.set(0, 0, 0);
                    const dechet2 = createDechet2(0, 300, 0);
                    scene.add(dechet2);
                    alert('Bien joué');
                    dechet = dechet2;
                    compteur += 1;
                    document.getElementById('point').innerHTML = 'Points : ' + compteur ;
                    console.log(compteur);
                }

                else if (selectedObject === poubelleJ && dechet.material.color.r > 0) {
					scene.remove(dechet);
					// selectedObject.add(dechet);
					// dechet.position.set(0, 0, 0);
                    const dechet2 = createDechet2(0, 300, 0);
                    scene.add(dechet2);
                    alert('Bien joué');
                    dechet = dechet2;
                    compteur += 1;
                    document.getElementById('point').innerHTML = 'Points : ' + compteur ;

                    console.log(compteur);
			    }

                else{
                    scene.remove(dechet);
                    const dechet2 = createDechet2(0, 300, 0);
                    scene.add(dechet2);
                    dechet = dechet2;
                }
            }
		}
        
        renderer.setClearColor(0xffffff, 1, 0);

        // Render the scene
        const animate = () => {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            dechet.rotation.y += 0.03
        };
        animate();




    </script>
</body>

</html>