<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Three.js Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.2/build/three.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
        "imports": {
            "three": "./node_modules/three/build/three.module.js",
            "orbitcontrols": "./node_modules/three/examples/jsm/controls/OrbitControls.js"
            
        }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'orbitcontrols';
        import { BoxLineGeometry } from './node_modules/three/examples/jsm/geometries/BoxLineGeometry.js';
        import { VRButton } from './node_modules/three/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from './node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js';

        // Create a Three.js scene
        const scene = new THREE.Scene();
        let room;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;

        // Create a camera
        const camera = new THREE.PerspectiveCamera(
            75, // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping plane
            1000 // Far clipping plane
        );
        camera.position.x = 10
        camera.position.y = 8
        camera.position.z = 0

        // Create a renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        document.body.appendChild( VRButton.createButton( renderer ) );

        // Create a cube
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const geometry = new THREE.BoxGeometry(2, 3, 2);
        const cubeMaterial = new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xff0000 : 0x0000ff });
        const recyclage = new THREE.MeshBasicMaterial({ color: 0xcccc00 });
        const pasrecyclage = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        const cube1 = new THREE.Mesh(geometry, recyclage);
        const cube2 = new THREE.Mesh(geometry, pasrecyclage);

        scene.add(cube, cube2, cube1);
        //----------PIECE----------------
        room = new THREE.LineSegments(
					new BoxLineGeometry( 60, 60, 60, 5, 5, 5 ).translate( 0, 30, 0 ),
					new THREE.LineBasicMaterial( { color: 0x808080 } )
			    );


		scene.add( room );

        function onSelectStart() {

            this.userData.isSelecting = true;

        }

            function onSelectEnd() {

            this.userData.isSelecting = false;

        }

        controller1 = renderer.xr.getController( 0 );
        controller1.addEventListener( 'selectstart', onSelectStart );
        controller1.addEventListener( 'selectend', onSelectEnd );
        controller1.addEventListener( 'connected', function ( event ) {

            this.add( buildController( event.data ) );

        } );
        controller1.addEventListener( 'disconnected', function () {

            this.remove( this.children[ 0 ] );

        } );
        scene.add( controller1 );

        controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', onSelectStart );
        controller2.addEventListener( 'selectend', onSelectEnd );
        controller2.addEventListener( 'connected', function ( event ) {

            this.add( buildController( event.data ) );

        } );
        controller2.addEventListener( 'disconnected', function () {

            this.remove( this.children[ 0 ] );

        } );
        scene.add( controller2 );

        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip( 0 );
        controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
        scene.add( controllerGrip1 );

        controllerGrip2 = renderer.xr.getControllerGrip( 1 );
        controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
        scene.add( controllerGrip2 );

        //

        window.addEventListener( 'resize', onWindowResize );

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }
        function handleController( controller ) {

            if ( controller.userData.isSelecting ) {

                const object = room.children[ count ++ ];

                object.position.copy( controller.position );
                object.userData.velocity.x = ( Math.random() - 0.5 ) * 3;
                object.userData.velocity.y = ( Math.random() - 0.5 ) * 3;
                object.userData.velocity.z = ( Math.random() - 9 );
                object.userData.velocity.applyQuaternion( controller.quaternion );

                if ( count === room.children.length ) count = 0;

        }

        }
        handleController( controller1 );
		handleController( controller2 );

        // Cube produit
        cube.position.x = 5;
        cube.position.y = 5;
        cube.position.z = 0;

        // Cube recyclage
        cube1.position.x = 0;
        cube1.position.y = 1.5;
        cube1.position.z = -2;

        // Cube pas recyclable
        cube2.position.x = 0;
        cube2.position.y = 1.5;
        cube2.position.z = 2;

        const axesHelper = new THREE.AxesHelper(100)
          // Ajouter les axes à la scène
        scene.add(axesHelper)

        let clicked = false;
        let originalColor = cubeMaterial.color.clone();
        const onClick = () => {
            if (!clicked) {
                clicked = true;
                cubeMaterial.color = new THREE.Color(0x00ff00);
                setTimeout(() => {
                    clicked = false;
                    cubeMaterial.color = originalColor;
                }, 1000);
            }
        };

        const control = new OrbitControls(camera, renderer.domElement)

        
        renderer.setClearColor(0xcccccc, 1, 0)

        // Render the scene
        const animate = () => {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            cube.rotation.y += 0.01
        };
        animate();




    </script>
</body>

</html>